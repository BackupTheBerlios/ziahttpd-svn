//
// resource.hh for  in 
// 
// Made by texane
// Login   <texane@gmail.com>
// 
// Started on  Wed Nov 23 13:04:52 2005 texane
// Last update Wed Nov 23 22:59:28 2005 texane
//


#ifndef DATAMAN_RESOURCE_HH
# define DATAMAN_RESOURCE_HH


#include <vector>
#include <string>
#include <dataman/buffer.hh>
#include <sysapi/sysapi.hh>


namespace dataman
{
  class resource
  {
    // -
    // Resource is an interface

  public:
    // Possible resource access failure
    typedef enum
      {
	EOFRES = 0,
	NOTFOUND,
	PERMDENIED,
	SYSLIMIT,
	NOTOPENED,
	ALREADYOPENED,
	INUSE
      } error_t;

    // Interface a concrete resource has to implement
    virtual bool open(error_t&) = 0;
    virtual bool fetch(buffer&, unsigned int, error_t&) = 0;
    virtual bool fetch(buffer&, error_t&) = 0;
    virtual bool close(error_t&) = 0;

    // Factory design pattern, by function overloading
    static resource* factory(const std::string& filename);
    static resource* factory(const std::vector<const std::string>&,
			     const std::vector<const std::string>&,
			     const dataman::buffer&);
    static resource* factory(unsigned int stcode);
  };
}


namespace dataman
{
  // -
  // File concrete resource

  class file : public resource
  {
  public:
    file(const std::string&);

    // Implement the resource interface
    bool open(error_t&);
    bool fetch(buffer&, unsigned int, error_t&);
    bool fetch(buffer&, error_t&);
    bool close(error_t&);

    // Destructor, close handle if
    // not close.
    virtual ~file();


  private:
    bool opened_;
    std::string filename_;
    sysapi::file::handle_t hfile_;
    sysapi::file::size_t sz_;
    
  };
}


namespace dataman
{
  // -
  // Cgi concrete resource

  class cgi : public resource
  {
  public:
    cgi(const std::vector<const std::string>&,
	const std::vector<const std::string>&,
	const dataman::buffer&);

    // Implement the resource interface
    bool open(error_t&);
    bool fetch(buffer&, unsigned int, error_t&);
    bool fetch(buffer&, error_t&);
    bool close(error_t&);

    // Destructor, release the process
    virtual ~cgi();

  private:
    unsigned int stcode_;
    buffer form_;
    bool formed_;

  };
}


namespace dataman
{
  // -
  // Report concrete resource.
  // Those are in-memory buffers
  // generated by fly (404 not found...)

  class report : public resource
  {
  public:
    report(unsigned int);

    // Implement the resource interface
    bool open(error_t&);
    bool fetch(buffer&, unsigned int, error_t&);
    bool fetch(buffer&, error_t&);
    bool close(error_t&);

    virtual ~report();

  private:

    // Status code
    unsigned int stcode_;
    bool formed_;
    std::string buf_;
  };
}


#endif // ! DATAMAN_RESOURCE_HH
